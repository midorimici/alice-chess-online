/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./config.ts":
/*!*******************!*\
  !*** ./config.ts ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__,\n/* harmony export */   \"Vec\": () => /* binding */ Vec\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    ivory: 'rgb(240, 227, 206)',\n    buff: 'rgb(179, 147, 105)',\n    dark: 'rgb(30, 30, 30)',\n    red: 'rgb(200, 0, 0)',\n    blue: 'rgb(0, 0, 200)',\n    grey: 'rgb(150, 150, 150)',\n    safe: 'rgb(121, 202, 68)',\n    squareSize: 9 / 80,\n    margin: 1 / 20,\n});\n/**\n * @classdesc 二次元ベクトルの計算を補助する\n */\nvar Vec = /** @class */ (function () {\n    /**\n     * @param v 二数の配列\n     */\n    function Vec(v) {\n        this.v = v;\n    }\n    /**\n     * Vec インスタンスから二数の配列を返す\n     */\n    Vec.prototype.val = function () {\n        return this.v;\n    };\n    /**\n     * ベクトルに加算する\n     * @param v 加算する数またはベクトル\n     */\n    Vec.prototype.add = function (v) {\n        if (Array.isArray(v)) {\n            return new Vec([v[0] + this.v[0], v[1] + this.v[1]]);\n        }\n        else {\n            return new Vec([v + this.v[0], v + this.v[1]]);\n        }\n    };\n    /**\n     * ベクトルに乗算する\n     * @param n 乗ずる数\n     */\n    Vec.prototype.mul = function (n) {\n        return new Vec([n * this.v[0], n * this.v[1]]);\n    };\n    /**\n     * ベクトルに除算する\n     * @param n 除する数\n     */\n    Vec.prototype.div = function (n) {\n        return new Vec([this.v[0] / n, this.v[1] / n]);\n    };\n    /**\n     * ベクトルに除算した商を返す\n     * @param n 除する数\n     */\n    Vec.prototype.quot = function (n) {\n        return new Vec([Math.floor(this.v[0] / n), Math.floor(this.v[1] / n)]);\n    };\n    return Vec;\n}());\n\n\n\n//# sourceURL=webpack://alice-chess-online/./config.ts?");

/***/ }),

/***/ "./svr/game.ts":
/*!*********************!*\
  !*** ./svr/game.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"opponent\": () => /* binding */ opponent,\n/* harmony export */   \"rotateBoard\": () => /* binding */ rotateBoard,\n/* harmony export */   \"isChecked\": () => /* binding */ isChecked,\n/* harmony export */   \"cannotMove\": () => /* binding */ cannotMove,\n/* harmony export */   \"castlingReq\": () => /* binding */ castlingReq,\n/* harmony export */   \"enPassantReq\": () => /* binding */ enPassantReq,\n/* harmony export */   \"renewBoard\": () => /* binding */ renewBoard\n/* harmony export */ });\n/* harmony import */ var _piece__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./piece */ \"./svr/piece.ts\");\n// ゲーム進行に関わる処理\nvar __values = (undefined && undefined.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = (undefined && undefined.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\n\n/** 自分の色と相手の色の対応 */\nvar opponent = { 'W': 'B', 'B': 'W' };\n/**\n* 盤面を変換する\n* @param boards 変換元の盤面\n*/\nvar rotateBoard = function (boards) {\n    var e_1, _a;\n    var orig = boards;\n    var res = new Map();\n    try {\n        for (var _b = __values(orig.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var _d = __read(_c.value, 2), pos = _d[0], piece = _d[1];\n            var _e = __read(pos.split(',').map(function (e) { return +e; }), 3), b = _e[0], x = _e[1], y = _e[2];\n            res.set(b + \",\" + (7 - x) + \",\" + (7 - y), piece);\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return res;\n};\n/**\n * color 側がチェックされているか\n * @param color 駒色\n * @param boards color の相手側から見た盤面\n */\nvar isChecked = function (color, boards) {\n    var e_2, _a, e_3, _b, e_4, _c;\n    var targetPos;\n    var enemies = new Map();\n    try {\n        // キングを探す\n        for (var _d = __values(boards.entries()), _e = _d.next(); !_e.done; _e = _d.next()) {\n            var _f = __read(_e.value, 2), pos = _f[0], piece = _f[1];\n            if (piece === color + 'K') {\n                targetPos = pos.split(',').map(function (e) { return +e; });\n                break;\n            }\n        }\n    }\n    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n    finally {\n        try {\n            if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n        }\n        finally { if (e_2) throw e_2.error; }\n    }\n    try {\n        // キングと同じ盤面上にある異色の駒を集める\n        for (var _g = __values(boards.entries()), _h = _g.next(); !_h.done; _h = _g.next()) {\n            var _j = __read(_h.value, 2), pos = _j[0], piece = _j[1];\n            if (targetPos[0] === +pos[0] && piece[0] !== color) {\n                var enemyPos = pos.split(',').map(function (e) { return +e; });\n                enemies.set([enemyPos[1], enemyPos[2]], new _piece__WEBPACK_IMPORTED_MODULE_0__.abbrPieceDict[piece[1]](opponent[color], +pos[0]));\n            }\n        }\n    }\n    catch (e_3_1) { e_3 = { error: e_3_1 }; }\n    finally {\n        try {\n            if (_h && !_h.done && (_b = _g.return)) _b.call(_g);\n        }\n        finally { if (e_3) throw e_3.error; }\n    }\n    try {\n        // 同盤面上の敵駒でキングを攻撃しているものがあるか\n        for (var _k = __values(enemies.entries()), _l = _k.next(); !_l.done; _l = _k.next()) {\n            var _m = __read(_l.value, 2), pos = _m[0], piece = _m[1];\n            if (~piece.coveringSquares(pos, boards).map(function (e) { return String(e); })\n                .indexOf(String(targetPos.slice(1)))) {\n                return true;\n            }\n        }\n    }\n    catch (e_4_1) { e_4 = { error: e_4_1 }; }\n    finally {\n        try {\n            if (_l && !_l.done && (_c = _k.return)) _c.call(_k);\n        }\n        finally { if (e_4) throw e_4.error; }\n    }\n    return false;\n};\n/**\n * color 側が駒を動かせないとき true を返す\n * @param color 駒色\n * @param boards color 側から見た盤面\n * @param advanced2Pos ポーンが 2 歩進んだときの移動先\n */\nvar cannotMove = function (color, boards, advanced2Pos, canCastle) {\n    var e_5, _a, e_6, _b;\n    try {\n        for (var _c = __values(boards.entries()), _d = _c.next(); !_d.done; _d = _c.next()) {\n            var _e = __read(_d.value, 2), posStr = _e[0], pieceName = _e[1];\n            if (color === pieceName[0]) {\n                var pos = posStr.split(',').map(function (e) { return +e; });\n                var piece = new _piece__WEBPACK_IMPORTED_MODULE_0__.abbrPieceDict[pieceName[1]](color, pos[0]);\n                try {\n                    for (var _f = (e_6 = void 0, __values(piece.validMoves([pos[1], pos[2]], boards, advanced2Pos, canCastle))), _g = _f.next(); !_g.done; _g = _f.next()) {\n                        var dest = _g.value;\n                        // 駒の各移動先について、移動後にチェック回避できるなら false\n                        var tmpBoards = new Map(boards);\n                        renewBoard(pos[0], [pos[1], pos[2]], dest, tmpBoards);\n                        if (!isChecked(color, rotateBoard(tmpBoards)))\n                            return false;\n                    }\n                }\n                catch (e_6_1) { e_6 = { error: e_6_1 }; }\n                finally {\n                    try {\n                        if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n                    }\n                    finally { if (e_6) throw e_6.error; }\n                }\n            }\n        }\n    }\n    catch (e_5_1) { e_5 = { error: e_5_1 }; }\n    finally {\n        try {\n            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        }\n        finally { if (e_5) throw e_5.error; }\n    }\n    return true;\n};\n/**\n * キャスリングの条件を満たすか\n * @param canCastle キャスリングのポテンシャルが残っているか\n * @param color 自分の駒色\n * @param side どちら側にキャスリングするか。0 - クイーンサイド, 1 - キングサイド\n * @param boardId 自分がいる盤面がどちらか\n * @param endPos キングの移動先の位置\n * @param boards 盤面\n */\nvar castlingReq = function (canCastle, color, side, boardId, endPos, boards) {\n    /**\n     * キングの通過するマスが攻撃されていないことを確認するために、\n     * キングがそのマスに動いたときに攻撃されるかを見るための\n     * 仮の盤面を出力する\n     * @param dest 行先の盤面と位置\n     */\n    var createTmpBoards = function (dest) {\n        var tmpBoards = new Map(boards);\n        var _a = __read(dest.split(','), 3), b = _a[0], _ = _a[1], y = _a[2];\n        tmpBoards.set(dest, color + 'K');\n        tmpBoards.delete(b + \",\" + calcX(4) + \",\" + y);\n        return tmpBoards;\n    };\n    /**\n     * キングが通るマスのどれかが相手の駒に攻撃されていれば false を返す\n     * @param kingRoute キングが通過するマスの x 位置\n     */\n    var pathIsNotAttacked = function (kingRoute) {\n        var e_7, _a;\n        try {\n            for (var kingRoute_1 = __values(kingRoute), kingRoute_1_1 = kingRoute_1.next(); !kingRoute_1_1.done; kingRoute_1_1 = kingRoute_1.next()) {\n                var x = kingRoute_1_1.value;\n                if (isChecked(color, rotateBoard(createTmpBoards(boardId + \",\" + x + \",7\")))) {\n                    return false;\n                }\n            }\n        }\n        catch (e_7_1) { e_7 = { error: e_7_1 }; }\n        finally {\n            try {\n                if (kingRoute_1_1 && !kingRoute_1_1.done && (_a = kingRoute_1.return)) _a.call(kingRoute_1);\n            }\n            finally { if (e_7) throw e_7.error; }\n        }\n        return true;\n    };\n    var calcX = function (v) {\n        return color === 'W' ? v : 7 - v;\n    };\n    var commonReq = \n    // キャスリングのポテンシャルが残っている\n    canCastle[color][side]\n        // 現在チェックされていない\n        && !isChecked(color, rotateBoard(boards))\n        // キャスリングに関与するルークが存在する\n        && boards.get(boardId + \",\" + 7 * side + \",7\") === color + 'R';\n    var specialReq;\n    if (side === 0) {\n        // クイーンサイド\n        specialReq =\n            // 終了位置指定\n            String(endPos) === calcX(2) + \",7\"\n                // キングとルークの間に駒がない\n                && !boards.has(boardId + \",\" + calcX(1) + \",7\")\n                && !boards.has(boardId + \",\" + calcX(2) + \",7\")\n                && !boards.has(boardId + \",\" + calcX(3) + \",7\")\n                // キャスリング後の対応するマスに駒がない\n                && !boards.has(1 - boardId + \",\" + calcX(2) + \",7\")\n                && !boards.has(1 - boardId + \",\" + calcX(3) + \",7\")\n                // キングが通過するマスが攻撃されていない\n                && pathIsNotAttacked([calcX(2), calcX(3)]);\n    }\n    else {\n        // キングサイド\n        specialReq =\n            // 終了位置指定\n            String(endPos) === calcX(6) + \",7\"\n                // キングとルークの間に駒がない\n                && !boards.has(boardId + \",\" + calcX(6) + \",7\")\n                && !boards.has(boardId + \",\" + calcX(5) + \",7\")\n                // キャスリング後の対応するマスに駒がない\n                && !boards.has(1 - boardId + \",\" + calcX(6) + \",7\")\n                && !boards.has(1 - boardId + \",\" + calcX(5) + \",7\")\n                // キングが通過するマスが攻撃されていない\n                && pathIsNotAttacked([calcX(6), calcX(5)]);\n    }\n    return commonReq && specialReq;\n};\n/**\n * en passant の条件を満たすか\n * @param startPos 駒の開始位置\n * @param endPos 駒の行先\n * @param pieceName 駒の名前\n * @param side 駒がいる盤面がどちらか\n * @param advanced2Side 2 歩進んだポーンの移動後の盤面がどちらか\n * @param boards 盤面\n */\nvar enPassantReq = function (startPos, endPos, pieceName, side, advanced2Side, boards) {\n    return pieceName === 'P'\n        && side === advanced2Side\n        && !boards.has(side + \",\" + String(endPos))\n        && startPos[1] === endPos[1] + 1\n        && Math.abs(startPos[0] - endPos[0]) === 1;\n};\n/**\n * 駒を移動して盤面を更新する\n * @param boardId 駒の移動前の盤面がどちらか\n * @param startpos 駒の移動前の位置\n * @param endpos 駒の移動後の位置\n * @param boards 盤面\n */\nvar renewBoard = function (boardId, startpos, endpos, boards) {\n    // 駒移動\n    boards.set(1 - boardId + \",\" + String(endpos), boards.get(boardId + \",\" + String(startpos)));\n    boards.delete(boardId + \",\" + String(startpos));\n    // 敵駒があったら削除\n    boards.delete(boardId + \",\" + String(endpos));\n};\n\n\n\n//# sourceURL=webpack://alice-chess-online/./svr/game.ts?");

/***/ }),

/***/ "./svr/piece.ts":
/*!**********************!*\
  !*** ./svr/piece.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Piece\": () => /* binding */ Piece,\n/* harmony export */   \"Knight\": () => /* binding */ Knight,\n/* harmony export */   \"Bishop\": () => /* binding */ Bishop,\n/* harmony export */   \"Rook\": () => /* binding */ Rook,\n/* harmony export */   \"Queen\": () => /* binding */ Queen,\n/* harmony export */   \"King\": () => /* binding */ King,\n/* harmony export */   \"Pawn\": () => /* binding */ Pawn,\n/* harmony export */   \"abbrPieceDict\": () => /* binding */ abbrPieceDict\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config */ \"./config.ts\");\n/* harmony import */ var _game__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./game */ \"./svr/game.ts\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __values = (undefined && undefined.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = (undefined && undefined.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\n\n\nvar Piece = /** @class */ (function () {\n    /**\n     * @param color 駒色\n     * @param name 駒の名前 'WB' など\n     * @param side 駒がどちらの盤にあるか\n     */\n    function Piece(color, side) {\n        this.color = color;\n        this.side = side;\n    }\n    /**\n     * 指定の位置が盤面内に収まっているか\n     * @param pos 位置\n     */\n    Piece.prototype.inBoard = function (pos) {\n        return pos[0] >= 0 && pos[0] < 8 && pos[1] >= 0 && pos[1] < 8;\n    };\n    /**\n     * 指定の位置に動かしてもよいか\n     * @param pos 位置\n     * @param boards 盤面\n     */\n    Piece.prototype.legal = function (pos, boards) {\n        var _a;\n        // 盤面内に収まる && 向こう側の盤面の対応する位置に駒がない && 行先に自分の駒がない\n        return this.inBoard(pos)\n            && boards.get(1 - this.side + \",\" + String(pos)) === undefined\n            && !(((_a = boards.get(this.side + \",\" + String(pos))) === null || _a === void 0 ? void 0 : _a[0]) === this.color);\n    };\n    /**\n     * 走り駒の行き先\n     * @param pos 駒の位置\n     * @param intervals 走る方向\n     * @param boards 盤面\n     */\n    Piece.prototype.rider = function (pos, intervals, boards) {\n        var e_1, _a;\n        var answers = [];\n        try {\n            for (var intervals_1 = __values(intervals), intervals_1_1 = intervals_1.next(); !intervals_1_1.done; intervals_1_1 = intervals_1.next()) {\n                var _b = __read(intervals_1_1.value, 2), dx = _b[0], dy = _b[1];\n                var xtmp = pos[0] + dx, ytmp = pos[1] + dy;\n                while (this.inBoard([xtmp, ytmp])) {\n                    var destThis = boards.get(this.side + \",\" + xtmp + \",\" + ytmp);\n                    var destThat = boards.get(1 - this.side + \",\" + xtmp + \",\" + ytmp);\n                    if (!destThat) {\n                        // 向こう側の盤のマスに何もない\n                        if (!destThis) {\n                            // こちら側の盤のマスに何もない\n                            answers.push([xtmp, ytmp]);\n                        }\n                        else if (destThis[0] !== this.color) {\n                            // 敵駒がある\n                            answers.push([xtmp, ytmp]);\n                            break;\n                        }\n                        else\n                            break;\n                    }\n                    xtmp += dx;\n                    ytmp += dy;\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (intervals_1_1 && !intervals_1_1.done && (_a = intervals_1.return)) _a.call(intervals_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return answers;\n    };\n    /**\n     * ゲーム内で駒が動ける位置リストを返す\n     * @param pos 駒の現在位置\n     * @param boards 盤面\n     * @param advanced2Pos ポーンが 2 歩進んだときの移動先\n     */\n    Piece.prototype.validMoves = function (pos, boards, advanced2Pos, canCastle) {\n        var e_2, _a, e_3, _b;\n        var result = [];\n        var dests = this.coveringSquares(pos, boards);\n        // キャスリング\n        if (this.abbr === 'K') {\n            try {\n                for (var _c = __values([0, 1]), _d = _c.next(); !_d.done; _d = _c.next()) {\n                    var i = _d.value;\n                    var endPos = (this.color === 'W'\n                        ? (i === 0 ? [2, 7] : [6, 7])\n                        : (i === 0 ? [5, 7] : [1, 7]));\n                    if (_game__WEBPACK_IMPORTED_MODULE_1__.castlingReq(canCastle, this.color, i, this.side, endPos, boards)) {\n                        dests.push(endPos);\n                    }\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n        }\n        // en passant\n        if (advanced2Pos) {\n            var endPos = [7 - advanced2Pos[1], 7 - advanced2Pos[2] - 1];\n            if (_game__WEBPACK_IMPORTED_MODULE_1__.enPassantReq(pos, endPos, this.abbr, this.side, advanced2Pos[0], boards)) {\n                dests.push(endPos);\n            }\n        }\n        try {\n            // チェック回避のための制限\n            for (var dests_1 = __values(dests), dests_1_1 = dests_1.next(); !dests_1_1.done; dests_1_1 = dests_1.next()) {\n                var dest = dests_1_1.value;\n                // 盤面の複製\n                var tmpBoards = new Map(boards);\n                // 盤面の更新\n                if (this.abbr === 'K') {\n                    // 動かす駒がキングのとき\n                    // その盤面上で合法である（敵の効きに移動していない）\n                    var tmpBoards2 = new Map(boards);\n                    tmpBoards2.set(this.side + \",\" + String(dest), this.color + 'K');\n                    tmpBoards2.delete(this.side + \",\" + String(pos));\n                    if (_game__WEBPACK_IMPORTED_MODULE_1__.isChecked(this.color, _game__WEBPACK_IMPORTED_MODULE_1__.rotateBoard(tmpBoards2)))\n                        continue;\n                    // 向こうの盤面のその位置も敵の効きでない\n                }\n                _game__WEBPACK_IMPORTED_MODULE_1__.renewBoard(this.side, pos, dest, tmpBoards);\n                // チェックにならないなら結果に追加\n                if (!_game__WEBPACK_IMPORTED_MODULE_1__.isChecked(this.color, _game__WEBPACK_IMPORTED_MODULE_1__.rotateBoard(tmpBoards))) {\n                    result.push(dest);\n                }\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (dests_1_1 && !dests_1_1.done && (_b = dests_1.return)) _b.call(dests_1);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        return result;\n    };\n    return Piece;\n}());\nvar Knight = /** @class */ (function (_super) {\n    __extends(Knight, _super);\n    function Knight() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.abbr = 'N';\n        return _this;\n    }\n    Knight.prototype.coveringSquares = function (pos, boards) {\n        var _this = this;\n        var dirList = [[1, 2], [2, 1], [2, -1], [1, -2],\n            [-1, -2], [-2, -1], [-2, 1], [-1, 2]];\n        return dirList\n            .map(function (e) { return new _config__WEBPACK_IMPORTED_MODULE_0__.Vec(pos).add(e).val(); })\n            .filter(function (dest) {\n            return _this.legal(dest, boards);\n        });\n    };\n    return Knight;\n}(Piece));\nvar Bishop = /** @class */ (function (_super) {\n    __extends(Bishop, _super);\n    function Bishop() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.abbr = 'B';\n        return _this;\n    }\n    Bishop.prototype.coveringSquares = function (pos, boards) {\n        return this.rider(pos, [[1, 1], [1, -1], [-1, -1], [-1, 1]], boards);\n    };\n    return Bishop;\n}(Piece));\nvar Rook = /** @class */ (function (_super) {\n    __extends(Rook, _super);\n    function Rook() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.abbr = 'R';\n        return _this;\n    }\n    Rook.prototype.coveringSquares = function (pos, boards) {\n        return this.rider(pos, [[1, 0], [0, -1], [-1, 0], [0, 1]], boards);\n    };\n    return Rook;\n}(Piece));\nvar Queen = /** @class */ (function (_super) {\n    __extends(Queen, _super);\n    function Queen() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.abbr = 'Q';\n        return _this;\n    }\n    Queen.prototype.coveringSquares = function (pos, boards) {\n        return this.rider(pos, [[1, 1], [1, -1], [-1, -1], [-1, 1], [1, 0], [0, -1], [-1, 0], [0, 1]], boards);\n    };\n    return Queen;\n}(Piece));\nvar King = /** @class */ (function (_super) {\n    __extends(King, _super);\n    function King() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.abbr = 'K';\n        return _this;\n    }\n    King.prototype.coveringSquares = function (pos, boards) {\n        var _this = this;\n        var dirList = [[1, 0], [1, -1], [0, -1], [-1, -1],\n            [-1, 0], [-1, 1], [0, 1], [1, 1]];\n        return dirList\n            .map(function (e) { return new _config__WEBPACK_IMPORTED_MODULE_0__.Vec(pos).add(e).val(); })\n            .filter(function (dest) {\n            return _this.legal(dest, boards);\n        });\n    };\n    return King;\n}(Piece));\nvar Pawn = /** @class */ (function (_super) {\n    __extends(Pawn, _super);\n    function Pawn() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.abbr = 'P';\n        return _this;\n    }\n    Pawn.prototype.coveringSquares = function (pos, boards) {\n        var _a, _b;\n        var answers = [];\n        // 駒を取る動き\n        var target = new _config__WEBPACK_IMPORTED_MODULE_0__.Vec(pos).add([1, -1]).val();\n        if (((_a = boards.get(this.side + \",\" + String(target))) === null || _a === void 0 ? void 0 : _a[0]) === _game__WEBPACK_IMPORTED_MODULE_1__.opponent[this.color]) {\n            answers.push(target);\n        }\n        var target = new _config__WEBPACK_IMPORTED_MODULE_0__.Vec(pos).add([-1, -1]).val();\n        if (((_b = boards.get(this.side + \",\" + String(target))) === null || _b === void 0 ? void 0 : _b[0]) === _game__WEBPACK_IMPORTED_MODULE_1__.opponent[this.color]) {\n            answers.push(target);\n        }\n        // 一歩先\n        var target = new _config__WEBPACK_IMPORTED_MODULE_0__.Vec(pos).add([0, -1]).val();\n        if (!boards.has(this.side + \",\" + String(target)) && this.legal(target, boards)) {\n            answers.push(target);\n        }\n        // 二歩先（最初だけ）\n        var target2 = new _config__WEBPACK_IMPORTED_MODULE_0__.Vec(pos).add([0, -2]).val();\n        if (pos[1] === 6\n            && !boards.has(this.side + \",\" + String(target))\n            && !boards.has(this.side + \",\" + String(target2))\n            && this.legal(target2, boards)) {\n            answers.push(target2);\n        }\n        return answers;\n    };\n    return Pawn;\n}(Piece));\nvar abbrPieceDict = { 'N': Knight, 'B': Bishop, 'R': Rook, 'Q': Queen, 'K': King, 'P': Pawn };\n\n\n\n//# sourceURL=webpack://alice-chess-online/./svr/piece.ts?");

/***/ }),

/***/ "./svr/server.ts":
/*!***********************!*\
  !*** ./svr/server.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var express__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! express */ \"express\");\n/* harmony import */ var express__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(express__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! http */ \"http\");\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(http__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _game__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./game */ \"./svr/game.ts\");\nvar __read = (undefined && undefined.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (undefined && undefined.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\n\n\n\nvar app = express__WEBPACK_IMPORTED_MODULE_0__();\napp.use(express__WEBPACK_IMPORTED_MODULE_0__.static(process.cwd() + '/public'));\nvar server = http__WEBPACK_IMPORTED_MODULE_1__.createServer(app);\nvar io = __webpack_require__(/*! socket.io */ \"socket.io\")(server, {\n    cors: {\n        origin: 'https://geister-online.netlify.app',\n        methods: ['GET', 'POST']\n    }\n});\napp.get('/', function (req, res) {\n    res.sendFile(process.cwd() + '/public/ja/index.html');\n});\n/** 部屋番号と部屋のデータの Map\n * @property player1 先に入室したプレイヤー\n * @property player2 後から入室したプレイヤー\n * @property state 部屋の状態\n*/\nvar rooms = new Map();\n/**\n * 先手の初期盤面を生成する\n * @returns Map\n */\nvar initBoard = function () {\n    var m = new Map();\n    var order = 'RNBQKBNR';\n    for (var i = 0; i < 8; i++) {\n        m.set(\"0,\" + i + \",7\", 'W' + order[i]);\n        m.set(\"0,\" + i + \",6\", 'WP');\n        m.set(\"0,\" + i + \",0\", 'B' + order[i]);\n        m.set(\"0,\" + i + \",1\", 'BP');\n    }\n    return m;\n};\n// 盤面。{'0,0,0': 'WN'} のフォーマット\n/** 先手から見た盤面, 後手から見た盤面 */\nvar boards;\n/** 先手, 後手の名前と socket id */\nvar players;\n/** 現在のターン */\nvar curTurn;\n/** 勝者 0 - 先手, 1 - 後手, 2 - 引き分け */\nvar winner;\n/** キャスリングのポテンシャルが残っているか */\nvar canCastle;\nio.on('connection', function (socket) {\n    socket.on('enter room', \n    /**\n     * 入室したときのサーバ側の処理\n     * @param info 入室者のデータ\n     */\n    function (info) {\n        var _a, _b, _c;\n        socket.info = info;\n        var room = rooms.get(info.roomId);\n        if (info.role === 'play') {\n            // 対戦者として参加\n            if (room) {\n                // 指定のルームに対戦者がいたとき\n                if (room.state === 'waiting') {\n                    // 対戦者が1人待機している\n                    room.player2 = {\n                        id: socket.id,\n                        name: info.name,\n                        turn: 1\n                    };\n                    room.state = 'playing';\n                    socket.join(info.roomId);\n                    players = [\n                        {\n                            name: room.player1.name,\n                            id: room.player1.id\n                        },\n                        {\n                            name: room.player2.name,\n                            id: room.player2.id\n                        }\n                    ];\n                    // 変数の初期化\n                    // 盤面生成\n                    boards = [initBoard(), new Map()];\n                    boards[1] = _game__WEBPACK_IMPORTED_MODULE_2__.rotateBoard(boards[0]);\n                    curTurn = 0;\n                    winner = null;\n                    canCastle = { 'W': [true, true], 'B': [true, true] };\n                    // クライアントへ送信\n                    (_a = io.to(info.roomId)).emit.apply(_a, __spread(['watch', __spread(boards[0])], players.map(function (e) { return e.name; }), [curTurn, false]));\n                    (_b = io.to(room.player1.id)).emit.apply(_b, __spread(['game', __spread(boards[0]), 'W', true], players.map(function (e) { return e.name; }), [false,\n                        null, canCastle]));\n                    (_c = io.to(room.player2.id)).emit.apply(_c, __spread(['game', __spread(boards[1]), 'B', false], players.map(function (e) { return e.name; }), [false,\n                        null, canCastle]));\n                }\n                else {\n                    // 対戦者がすでに2人いる\n                    socket.emit('room full', info.roomId);\n                    socket.info.role = 'watch';\n                }\n            }\n            else {\n                // 新たにルームを作成する\n                rooms.set(info.roomId, {\n                    player1: {\n                        id: socket.id,\n                        name: info.name,\n                        turn: 0\n                    },\n                    player2: {\n                        id: '',\n                        name: '',\n                        turn: 0\n                    },\n                    state: 'waiting'\n                });\n                socket.join(info.roomId);\n                socket.emit('wait opponent');\n            }\n        }\n        else {\n            // 観戦者として参加\n            if (room) {\n                // 指定のルームが存在するとき\n                socket.join(info.roomId);\n                if (room.state === 'waiting') {\n                    // 対戦者が1人待機している\n                    socket.emit('wait opponent');\n                }\n                else {\n                    // 対戦者がすでに2人いて対戦中\n                    socket.emit.apply(socket, __spread(['watch', __spread(boards[0])], players.map(function (e) { return e.name; }), [curTurn, false]));\n                    if (winner) {\n                        socket.emit('tell winner', players.map(function (e) { return e.name; })[winner]);\n                    }\n                }\n            }\n            else {\n                // 指定したルームがないとき\n                socket.emit('no room', info.roomId);\n            }\n        }\n    });\n    socket.on('move piece', \n    /**\n     * 駒を動かしたときのサーバ側の処理\n     * @param boardId 駒の移動前の盤面がどちらか\n     * @param from 駒の移動前の位置\n     * @param to 駒の移動後の位置\n     * @param promoteTo プロモーションのとき、プロモーション先\n     */\n    function (boardId, from, to, promoteTo) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        var _h;\n        var roomId = socket.info.roomId;\n        var colors = ['W', 'B'];\n        var newBoard = boards[curTurn];\n        var pieceName = (_h = newBoard.get(boardId + \",\" + String(from))) === null || _h === void 0 ? void 0 : _h[1];\n        // キャスリング\n        // ルークが動いた\n        if (pieceName === 'R') {\n            // クイーンサイド\n            if (String(from) === '0,7') {\n                canCastle[colors[curTurn]][curTurn] = false;\n            }\n            // キングサイド\n            if (String(from) === '7,7') {\n                canCastle[colors[curTurn]][1 - curTurn] = false;\n            }\n        }\n        // キングが動いた\n        if (pieceName === 'K') {\n            canCastle[colors[curTurn]] = [false, false];\n            // キャスリングが行われたときルークを動かす\n            if (Math.abs(to[0] - from[0]) === 2) {\n                var newX = void 0, oldX = void 0;\n                switch (to[0]) {\n                    case 2:\n                        // 白クイーンサイド\n                        _a = __read([3, 0], 2), newX = _a[0], oldX = _a[1];\n                        break;\n                    case 6:\n                        // 白キングサイド\n                        _b = __read([5, 7], 2), newX = _b[0], oldX = _b[1];\n                        break;\n                    case 5:\n                        // 黒クイーンサイド\n                        _c = __read([4, 7], 2), newX = _c[0], oldX = _c[1];\n                        break;\n                    case 1:\n                        // 黒キングサイド\n                        _d = __read([2, 0], 2), newX = _d[0], oldX = _d[1];\n                        break;\n                }\n                newBoard.set(1 - boardId + \",\" + newX + \",7\", colors[curTurn] + 'R');\n                newBoard.delete(boardId + \",\" + oldX + \",7\");\n            }\n        }\n        // en passant\n        if (_game__WEBPACK_IMPORTED_MODULE_2__.enPassantReq(from, to, pieceName, boardId, boardId, newBoard)) {\n            // ポーンを除去する\n            newBoard.delete(boardId + \",\" + to[0] + \",\" + (to[1] + 1));\n        }\n        // ポーンが 2 歩進んだときの移動先\n        var advanced2Pos = (pieceName === 'P' && from[1] - to[1] === 2)\n            ? __spread([1 - boardId], to) : null;\n        // 駒の移動\n        _game__WEBPACK_IMPORTED_MODULE_2__.renewBoard(boardId, from, to, newBoard);\n        if (promoteTo) {\n            // プロモーション\n            newBoard.set(1 - boardId + \",\" + String(to), colors[curTurn] + promoteTo);\n        }\n        // 相手目線のボードを更新する\n        boards[1 - curTurn] = _game__WEBPACK_IMPORTED_MODULE_2__.rotateBoard(newBoard);\n        // ターン交代\n        curTurn = 1 - curTurn;\n        // チェック判定\n        var checked = _game__WEBPACK_IMPORTED_MODULE_2__.isChecked(colors[curTurn], boards[1 - curTurn]);\n        var freezed = _game__WEBPACK_IMPORTED_MODULE_2__.cannotMove(colors[curTurn], boards[curTurn], advanced2Pos, canCastle);\n        // 勝敗判定\n        if (freezed) {\n            if (checked) {\n                winner = 1 - curTurn;\n            }\n            else {\n                winner = 2;\n            }\n        }\n        // 盤面データをクライアントへ\n        (_e = io.to(roomId)).emit.apply(_e, __spread(['watch', __spread(boards[0])], players.map(function (e) { return e.name; }), [curTurn, checked]));\n        (_f = io.to(players[0].id)).emit.apply(_f, __spread(['game', __spread(boards[0]), 'W', curTurn === 0], players.map(function (e) { return e.name; }), [checked, advanced2Pos, canCastle]));\n        (_g = io.to(players[1].id)).emit.apply(_g, __spread(['game', __spread(boards[1]), 'B', curTurn === 1], players.map(function (e) { return e.name; }), [checked, advanced2Pos, canCastle]));\n        // 勝者を通知する\n        if (winner) {\n            io.to(roomId).emit('tell winner', players.map(function (e) { return e.name; })[winner]);\n        }\n    });\n    socket.on('chat message', function (msg) {\n        io.to(socket.info.roomId).emit('chat message', msg, socket.info.role === 'play', socket.info.name);\n    });\n    socket.on('disconnect', function () {\n        var info = socket.info;\n        // 接続が切れたとき\n        if (info) {\n            // ルームに入っていたとき\n            if (info.role === 'play') {\n                // 対戦者としてルームにいたとき\n                rooms.delete(info.roomId);\n                // 観戦者ともう一方の対戦者も退出させる\n                socket.to(info.roomId).leave(info.roomId);\n                socket.to(info.roomId).emit('player discon', info.name);\n            }\n        }\n    });\n});\nserver.listen(process.env.PORT || 3000);\n\n\n//# sourceURL=webpack://alice-chess-online/./svr/server.ts?");

/***/ }),

/***/ "express":
/*!**************************!*\
  !*** external "express" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("express");;

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("http");;

/***/ }),

/***/ "socket.io":
/*!****************************!*\
  !*** external "socket.io" ***!
  \****************************/
/***/ ((module) => {

module.exports = require("socket.io");;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => module['default'] :
/******/ 				() => module;
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	__webpack_require__("./svr/server.ts");
/******/ 	// This entry module used 'exports' so it can't be inlined
/******/ })()
;